global !p
from snippet_helpers import *
from php_snippet_helpers import *
endglobal

snippet c "Generate Class" b
<?php
namespace `!p snip.rv = get_namespace(path)`;

class `!p snip.rv = get_classname(fn)`
{
	$0
}
endsnippet

snippet i "Generate Interface" b
<?php
namespace `!p snip.rv = get_namespace(path)`;

interface `!p snip.rv = get_classname(fn)`
{
	$0
}
endsnippet

snippet t "Generate Interface" b
<?php
namespace `!p snip.rv = get_namespace(path)`;

trait `!p snip.rv = get_classname(fn)`
{
	$0
}
endsnippet

snippet cnstr
public function __construct(
    $1 \$`!p snip.rv = lcfirst(t[1])`
) {
    \$this->set$1(\$`!p snip.rv = lcfirst(t[1])`);
}
endsnippet

snippet todo
// TODO
// $0
// TODO
endsnippet

snippet addsv
public function add`!p snip.rv = ucfirst(t[1])`(\$$1)
{
	\$this->$1s[] = \$$1;
	return \$this;
}

public function get`!p snip.rv = ucfirst(t[1])`s()
{
	return \$this->$1s;
}
endsnippet

snippet addso
/**
 * @return self
 */
public function add$1($1 \$`!p snip.rv = lcfirst(t[1])`)
{
	\$this->`!p snip.rv = lcfirst(t[1])`s[] = \$`!p snip.rv = lcfirst(t[1])`;
	return \$this;
}

protected function get$1()
{
	return \$this->`!p snip.rv = lcfirst(t[1])`s;
}
endsnippet

snippet gsv
/**
 * @return self
 */
public function set`!p snip.rv = ucfirst(t[1])`(\$$1)
{
	\$this->$1 = (${2:string}) \$$1;
	return \$this;
}

/**
 * @return $2
 */
public function get`!p snip.rv = ucfirst(t[1])`()
{
	return \$this->$1;
}
endsnippet

snippet gsa
/**
 * @return self
 */
public function set`!p snip.rv = ucfirst(t[1])`(array \$$1)
{
	\$this->$1 = \$$1;
	return \$this;
}

/**
 * @return array
 */
public function get`!p snip.rv = ucfirst(t[1])`()
{
	return \$this->$1;
}
endsnippet

snippet gso
/**
 * @return self
 */
public function set$1($1 \$`!p snip.rv = lcfirst(t[1])`)
{
	\$this->`!p snip.rv = lcfirst(t[1])` = \$`!p snip.rv = lcfirst(t[1])`;
	return \$this;
}

/**
 * @return $1
 */
protected function get$1()
{
	return \$this->`!p snip.rv = lcfirst(t[1])`;
}
endsnippet

snippet try
try {
    ${VISUAL}$2
} catch ($1 \$e) {
    $3
}
endsnippet

snippet trydie
try {
    ${VISUAL}$2
} catch (\Exception \$e) {
	var_dump(get_class($e));
	var_dump($e->getMessage());
    var_dump($e->getTraceAsString());
	die(__CLASS__ . " " . __FUNCTION__ . " " . __LINE__);
}
endsnippet

snippet tryf
try {
    ${VISUAL}$2
} finally {
    $1
}
endsnippet

snippet echo
echo "$1" . PHP_EOL;
endsnippet

snippet if
if (${1:/* condition */}) {
	${VISUAL}${0}
}
endsnippet

snippet die
die(__CLASS__ . " " . __FUNCTION__ . " " . __LINE__);
endsnippet

snippet vdd
var_dump(${VISUAL}${0});
die(__CLASS__ . " " . __FUNCTION__ . " " . __LINE__);
endsnippet

snippet vd
var_dump(${VISUAL}${0});
endsnippet

snippet foocl
class Foo
{
	${VISUAL}${0}
}

\$foo = new Foo();
endsnippet

snippet usephpunit
use PHPUnit_Framework_TestCase;
endsnippet

snippet trace "Dump out stack trace" b
var_dump((new \Exception())->getTraceAsString());
die(__CLASS__ . " " . __FUNCTION__ . " " . __LINE__);
endsnippet

snippet todoe "Throw todo exception" b
throw new \Exception('TODO: ${1:Implement method}');
$0
endsnippet

snippet aset "isset in an array" b
isset($${2:data}['$1']) ? $$2['$1']: ${3:null}$0
endsnippet

snippet pub "Override annoying snippet" b
public
endsnippet

snippet pro "Override annoying snippet" b
protected
endsnippet

snippet puf "Public class method" b
public function $1(${2:})
{
	$0
}
endsnippet

snippet prf "Protected class method" b
protected function $1(${2:})
{
	$0
}
endsnippet

snippet cauto "Require vendor/autoload" b
require_once "vendor/autoload.php";
$0
endsnippet
