#!/bin/bash

_git_status() {
    git status
}

_git_pull() {
    git fetch && git pull origin $(git rev-parse --abbrev-ref HEAD)
    echo "Log:"
    git log --color --pretty=oneline --abbrev-commit HEAD@{1}.. | sed 's/^/  /'
}

_fuzzy_branch() {
    git for-each-ref --format='%(refname:short)' | fzf +m --query="$@"
}

_fuzzy_commit() {
    git log --pretty=oneline | fzf -m | cut -c 1-40
}

_fuzzy_show() {
    commit=$(_fuzzy_commit) && git show $commit
}

_fuzzy_git() {
    while true; do
        echo "Select an option:"
        echo -ne "\t1 - show"
        echo -ne "\n:"
        read opt
        case "$opt" in
            1)
                _fuzzy_show
                break
                ;;
        esac
    done
}

_checkout_merge() {
    if [ -z "$@" ]; then
        git checkout - && git merge -
    else
        git checkout "$@" && git merge -
    fi
}

_is_master() {
    local branches=( develop master )
    local e
    for e in "${branches[@]}"; do [[ "$e" == "$1" ]] && return 0; done
    return 1
}

_prompt_pull() {
    branch="`git rev-parse --abbrev-ref HEAD 2>&1`"
    if [[ "$branch" =~ Not\ a\ git\ repo ]]; then
        echo "Not a git repository: $PWD"
        return 1
    fi
    _is_master $branch
    if ! [ $? -eq 0 ]; then
        while true; do
            read -p "You are not on develop or master of ${PWD}, do you still want to pull? " yn
            case "$yn" in
                [Yy]*) break;;
                [Nn]*) return 1;;
            esac
        done
    fi
    echo "Pulling origin/$branch in $PWD"
    pull="`git pull origin $branch 2>&1`"
}

_git_pull_recurse() {
    local base_branch="`git rev-parse --abbrev-ref HEAD 2>&1`"
    if ! [[ "$base_branch" =~ Not\ a\ git\ repo ]]; then
        while true; do
            read -p "You are currently in a git repository, are you sure you want to pull recursively? " bb
            case "$bb" in
                [Yy]*) break;;
                [Nn]*) exit 1;;
            esac
        done
    fi
    for path in $(pwd)/*; do
        [ -d "${path}" ] || continue
        (cd ${path} && _prompt_pull)
    done
}

_git_pull_merge() {
    branch=$1
    git checkout $branch
    git pull origin $branch
    git checkout -
    git merge -
}

if [ $# -eq 0 ]; then
    _git_status
    exit 0
fi

OP=$1
shift
case "$OP" in
    a) git add "$@" ;;
    b) git blame "$@" ;;
    c) git commit "$@" ;;
    d)
        if [ $# -eq 0 ]; then
            git diff
        elif [ $1 == "-" ]; then
            git diff @{-1}
        elif [ $1 == "-z" ]; then
            shift
            branch=$(_fuzzy_branch "$@") && git diff $branch
        else
            case $1 in
                h) git diff HEAD ;;
                *) git diff "$@"
            esac
        fi
        ;;
    f) git fetch "$@" ;;
    l)
        if [ $# -eq 0 ]; then
            git log --stat
        else
            git log "$@"
        fi
        ;;
    r) git reset "$@" ;;
    s)
        if [ $# -eq 0 ]; then
            git stash
        else
            case $1 in
                a) git stash apply ;;
                d) git stash drop ;;
                p) git stash pop ;;
                *) git stash "$@" ;;
            esac
        fi
        ;;
    st) git status "$@" ;;
    li) git ls-files "$@" ;;
    m)
        if [ $# -eq 0 ]; then
            git merge -
        elif [ $1 == "-p" ]; then
            shift
            _git_pull_merge $1
        elif [ $1 == "-z" ]; then
            shift
            branch=$(_fuzzy_branch "$@") && git merge $branch
        else
            git merge "$@"
        fi
        ;;
    ch)
        if [ $# -eq 0 ]; then
            git checkout -q -
        elif [ $1 == "-m" ]; then
            shift
            _checkout_merge "$@"
        elif [ $1 == "-z" ]; then
            shift
            branch=$(_fuzzy_branch "$@") && git checkout $branch
        else
            git checkout -q "$@"
        fi
        ;;
    ps)
        if [ $# -eq 0 ]; then
            git push origin $(git rev-parse --abbrev-ref HEAD)
        else
            git push "$@"
        fi
        ;;
    pl)
        if [ $# -eq 0 ]; then
            _git_pull
        elif [ $1 == "--recurse" ]; then
            _git_pull_recurse
        else
            git pull "$@"
        fi
        ;;
    z) _fuzzy_git "$@" ;;
    wtf)
        shift
        if hash git-wtf 2>/dev/null; then
            git-wtf "$@"
        else
            echo "git-wtf not installed from dotfiles"
        fi
        ;;
    *)
        git $OP "$@"
        ;;
esac
